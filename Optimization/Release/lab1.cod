; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	c:\users\1610036\source\repos\lab1_program_languages\lab1_program_languages\lab1.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_05COLMCDPH@Hello@				; `string'
PUBLIC	??_C@_0CC@DDFJGIGO@Common?5subexpression?5eliminatio@ ; `string'
PUBLIC	??_C@_0CA@EAKPGJJD@This?5line?5should?5not?5be?5printed@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	@__security_check_cookie@4:PROC
COMM	_j:DWORD
COMM	_k3:DWORD
COMM	_i4:DWORD
COMM	_i:DWORD
COMM	_j5:DWORD
COMM	_k:DWORD
COMM	_ivector4:WORD:06H
COMM	_i2:DWORD
COMM	_ivector5:DWORD:064H
COMM	_h3:DWORD
COMM	_ivector:DWORD:03H
COMM	_i3:DWORD
COMM	_i5:DWORD
COMM	_ivector2:BYTE:03H
COMM	_k5:DWORD
COMM	_j4:DWORD
_DATA	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EAKPGJJD@This?5line?5should?5not?5be?5printed@
CONST	SEGMENT
??_C@_0CA@EAKPGJJD@This?5line?5should?5not?5be?5printed@ DB 'This line sh'
	DB	'ould not be printed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DDFJGIGO@Common?5subexpression?5eliminatio@
CONST	SEGMENT
??_C@_0CC@DDFJGIGO@Common?5subexpression?5eliminatio@ DB 'Common subexpre'
	DB	'ssion elimination', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05COLMCDPH@Hello@
CONST	SEGMENT
??_C@_05COLMCDPH@Hello@ DB 'Hello', 00H			; `string'
CONST	ENDS
PUBLIC	_jump_compression
PUBLIC	_loop_unrolling
PUBLIC	_loop_jamming
PUBLIC	_unnecessary_loop
PUBLIC	_dead_code
PUBLIC	_main
PUBLIC	_printf
PUBLIC	__vfprintf_l
PUBLIC	___local_stdio_printf_options
EXTRN	__fltused:DWORD
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Locale$dead$ = 8					; size = 4
__ArgList$ = 12						; size = 4
__vfprintf_l PROC					; COMDAT
; __Stream$ = ecx
; __Format$ = edx

; 642  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00003	ff 75 0c	 push	 DWORD PTR __ArgList$[ebp]
  00006	6a 00		 push	 0
  00008	52		 push	 edx
  00009	51		 push	 ecx
  0000a	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0000f	ff 70 04	 push	 DWORD PTR [eax+4]
  00012	ff 30		 push	 DWORD PTR [eax]
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  0001a	83 c4 18	 add	 esp, 24			; 00000018H

; 644  :     }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);
; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Format$[ebp]
  00007	6a 01		 push	 1
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0000f	83 c4 04	 add	 esp, 4

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00012	8d 4d 0c	 lea	 ecx, DWORD PTR __Format$[ebp+4]
  00015	51		 push	 ecx
  00016	6a 00		 push	 0
  00018	56		 push	 esi
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001f	ff 70 04	 push	 DWORD PTR [eax+4]
  00022	ff 30		 push	 DWORD PTR [eax]
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  0002a	83 c4 18	 add	 esp, 24			; 00000018H

; 959  :         __crt_va_end(_ArgList);
; 960  :         return _Result;

  0002d	5e		 pop	 esi

; 961  :     }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\1610036\source\repos\Lab1_Program_Languages\Lab1_Program_Languages\lab1.c
;	COMDAT _main
_TEXT	SEGMENT
tv640 = -4						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 54   :     /* ──────────────────────────── *
; 55   :          │ Отказ от циклов │
; 56   :          *──────────────────────────────*/
; 57   :     for (i = 0; i < 3; i++) ivector[i] = 1;

  00004	33 c0		 xor	 eax, eax
  00006	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@main:
  00010	c7 04 85 00 00
	00 00 01 00 00
	00		 mov	 DWORD PTR _ivector[eax*4], 1
  0001b	40		 inc	 eax
  0001c	83 f8 03	 cmp	 eax, 3
  0001f	7c ef		 jl	 SHORT $LL4@main

; 58   : 
; 59   :     /* ──────────────────────────── *
; 60   :          │ Переприсваивание│
; 61   :          *──────────────────────────────*/
; 62   :     i2 = 5;
; 63   :     j4 = 6;
; 64   :     i2 = j4;
; 65   :     /* ──────────────────────────── *
; 66   :          │ Размножение констант и копий │
; 67   :          *──────────────────────────────*/
; 68   : 
; 69   :     j4 = 2;
; 70   :     if (i2 < j4 && i4 < j4) {
; 71   :         i2 = 2;
; 72   :         printf("Hello");
; 73   :     }
; 74   : 
; 75   :     j4 = k5;

  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _k5
  00027	a3 00 00 00 00	 mov	 DWORD PTR _i, eax
  0002c	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR _i2, 6
  00036	89 0d 00 00 00
	00		 mov	 DWORD PTR _j4, ecx

; 76   :     if (i2 < j4 && i4 < j4) {

  0003c	83 f9 06	 cmp	 ecx, 6
  0003f	7e 24		 jle	 SHORT $LN18@main
  00041	39 0d 00 00 00
	00		 cmp	 DWORD PTR _i4, ecx
  00047	7d 1c		 jge	 SHORT $LN18@main

; 77   :         i5 = 3;
; 78   :         printf("Hello");

  00049	68 00 00 00 00	 push	 OFFSET ??_C@_05COLMCDPH@Hello@
  0004e	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR _i5, 3
  00058	e8 00 00 00 00	 call	 _printf
  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR _i
  00062	83 c4 04	 add	 esp, 4
$LN18@main:

; 79   :     }
; 80   : 
; 81   :     /* ────────────────────────────────────────── *
; 82   :  │ Свертка констант, арифметические тождества │
; 83   :      │ и излишние операции загрузки/сохранения    │
; 84   :      * ────────────────────────────────────────── */
; 85   : 
; 86   :     i3 = 1 + 2;

  00065	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR _i3, 3

; 87   :     flt_1 = 2.4 + 6.3;
; 88   :     i2 = 5;
; 89   :     j2 = i + 0;
; 90   :     k2 = i / 1;
; 91   :     i4 = i * 1;
; 92   :     i5 = i * 0;
; 93   : 
; 94   :     // #ifndef NO_ZERO_DIVIDE
; 95   :       /*
; 96   :            *   Некоторые компиляторы распознают ошибку
; 97   :            *   деления на нуль и не генерируют объектный код
; 98   :            */
; 99   :            /*    i2 = i / 0;
; 100  :                flt_2 = flt_1 / 0.0;
; 101  :           #else
; 102  :                printf( "This compiler handles divide-by-zero as \
; 103  :                        an error\n");
; 104  :           #endif
; 105  :                flt_3 = 2.4 / 1.0;
; 106  :                flt_4 = 1.0 + 0.0000001;
; 107  :                flt_5 = flt_6 * 0.0;
; 108  :            flt_6 = flt_2 * flt_3;*/
; 109  : 
; 110  :            /* ──────────────────── *
; 111  :             │  Лишнее присваивание │
; 112  :             * ──────────────────── */
; 113  : 
; 114  :     k3 = 1;
; 115  :     k3 = 1;
; 116  : 
; 117  :     /* ────────────────── *
; 118  :      │  Снижение мощности │
; 119  :      * ────────────────── */
; 120  : 
; 121  :     k2 = 4 * j5;
; 122  :     for (i = 0; i <= 5; i++)

  0006f	33 c9		 xor	 ecx, ecx
  00071	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR _i2, 5
  0007b	a3 00 00 00 00	 mov	 DWORD PTR _i4, eax
  00080	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _k3, 1
  0008a	66 0f 1f 44 00
	00		 npad	 6
$LL7@main:

; 123  :         ivector4[i] = i * 2;

  00090	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  00093	66 89 04 4d 00
	00 00 00	 mov	 WORD PTR _ivector4[ecx*2], ax
  0009b	41		 inc	 ecx
  0009c	83 f9 05	 cmp	 ecx, 5
  0009f	7e ef		 jle	 SHORT $LL7@main

; 124  : 
; 125  :     /* ───────────── *
; 126  :          │  Простой цикл │
; 127  :          * ───────────── */
; 128  : 
; 129  :     j5 = 0;

  000a1	53		 push	 ebx
  000a2	56		 push	 esi
  000a3	33 f6		 xor	 esi, esi

; 130  :     k5 = 10000;

  000a5	b9 2d 75 00 00	 mov	 ecx, 29997		; 0000752dH
  000aa	57		 push	 edi
  000ab	bf 10 27 00 00	 mov	 edi, 10000		; 00002710H
  000b0	8d 5e 05	 lea	 ebx, DWORD PTR [esi+5]
$LL10@main:

; 131  :     do {
; 132  :         k5 = k5 - 1;

  000b3	8b c1		 mov	 eax, ecx
  000b5	4f		 dec	 edi
  000b6	83 e9 03	 sub	 ecx, 3

; 133  :         j5 = j5 + 1;
; 134  :         i5 = (k5 * 3) / (j5 * constant5);

  000b9	99		 cdq
  000ba	89 4d fc	 mov	 DWORD PTR tv640[ebp], ecx
  000bd	46		 inc	 esi
  000be	8b cb		 mov	 ecx, ebx
  000c0	83 c3 05	 add	 ebx, 5
  000c3	f7 f9		 idiv	 ecx

; 135  :     } while (k5 > 0);

  000c5	8b 4d fc	 mov	 ecx, DWORD PTR tv640[ebp]
  000c8	a3 00 00 00 00	 mov	 DWORD PTR _i5, eax
  000cd	85 ff		 test	 edi, edi
  000cf	7f e2		 jg	 SHORT $LL10@main

; 136  : 
; 137  :     /* ────────────────────────────────────── *
; 138  :  │  Управление переменной индукции цикла  │
; 139  :      * ────────────────────────────────────── */
; 140  :     for (i = 0; i < 100; i++)

  000d1	89 35 00 00 00
	00		 mov	 DWORD PTR _j5, esi
  000d7	33 c9		 xor	 ecx, ecx
  000d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@main:

; 141  :         ivector5[i * 2 + 3] = 5;

  000e0	c7 04 cd 0c 00
	00 00 05 00 00
	00		 mov	 DWORD PTR _ivector5[ecx*8+12], 5
  000eb	41		 inc	 ecx
  000ec	83 f9 64	 cmp	 ecx, 100		; 00000064H
  000ef	7c ef		 jl	 SHORT $LL13@main

; 142  : 
; 143  :     /* ─────────────────────── *
; 144  :      │  Глубокие подвыражения  │
; 145  :      * ─────────────────────── */
; 146  : 
; 147  :     if (i < 10)
; 148  :         j5 = i5 + i2;
; 149  :     else
; 150  :         k5 = i5 + i2;

  000f1	83 c0 05	 add	 eax, 5
  000f4	89 0d 00 00 00
	00		 mov	 DWORD PTR _i, ecx
  000fa	a3 00 00 00 00	 mov	 DWORD PTR _k5, eax

; 151  : 
; 152  :     /* ──────────────────────────────────────────────── *
; 153  :      │  Проверка того, как компилятор генерирует адрес  │
; 154  :      │  переменной с константным индексом, размножает   │
; 155  :      │  копии и регистры                                │
; 156  :      * ──────────────────────────────────────────────── */
; 157  : 
; 158  :     ivector[0] = 1;  /* генерация константного адреса */
; 159  :     ivector[i2] = 2; /* значение i2 должно быть скопировано*/
; 160  :     ivector[i2] = 2; /* копирование регистров */
; 161  :     ivector[2] = 3;  /* генарация константного адреса */
; 162  : 
; 163  : 
; 164  : /* ───────────────────────────── *
; 165  :      │  Удаление общих подвыражений  │
; 166  :      * ───────────────────────────── */
; 167  : 
; 168  :     if ((h3 + k3) < 0 || (h3 + k3) > 5)

  000ff	a1 00 00 00 00	 mov	 eax, DWORD PTR _h3
  00104	83 c0 01	 add	 eax, 1
  00107	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _ivector, 1
  00111	c7 05 14 00 00
	00 02 00 00 00	 mov	 DWORD PTR _ivector+20, 2
  0011b	c7 05 08 00 00
	00 03 00 00 00	 mov	 DWORD PTR _ivector+8, 3
  00125	78 05		 js	 SHORT $LN23@main
  00127	83 f8 05	 cmp	 eax, 5
  0012a	7e 0d		 jle	 SHORT $LN22@main
$LN23@main:

; 169  :         printf("Common subexpression elimination\n");

  0012c	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@DDFJGIGO@Common?5subexpression?5eliminatio@
  00131	e8 00 00 00 00	 call	 _printf
  00136	83 c4 04	 add	 esp, 4
$LN22@main:

; 170  :     else {
; 171  :         m3 = (h3 + k3) / i3;
; 172  :         g3 = i3 + (h3 + k3);
; 173  :     }
; 174  : 
; 175  :     /* ────────────────────────────────────── *
; 176  :      │  Вынесение инвариантного кода          │
; 177  :      │  (j * k) может быть вынесено из цикла  │
; 178  :  * ────────────────────────────────────── */
; 179  : 
; 180  :     for (i4 = 0; i4 <= max_vector; i4++) {

  00139	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _i4, 0
$LL16@main:

; 181  :         printf("Hello");

  00143	68 00 00 00 00	 push	 OFFSET ??_C@_05COLMCDPH@Hello@
  00148	e8 00 00 00 00	 call	 _printf

; 182  :         ivector2[i4] = j * k;

  0014d	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _k
  00154	83 c4 04	 add	 esp, 4
  00157	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _j
  0015e	0f af c8	 imul	 ecx, eax
  00161	a1 00 00 00 00	 mov	 eax, DWORD PTR _i4
  00166	88 88 00 00 00
	00		 mov	 BYTE PTR _ivector2[eax], cl
  0016c	40		 inc	 eax
  0016d	a3 00 00 00 00	 mov	 DWORD PTR _i4, eax
  00172	83 f8 02	 cmp	 eax, 2
  00175	7e cc		 jle	 SHORT $LL16@main

; 235  :     for (i = 0; i < 5; i++)  /* Цикл не должен

  00177	33 c0		 xor	 eax, eax
  00179	0f 1f 80 00 00
	00 00		 npad	 7
$LL28@main:
  00180	40		 inc	 eax
  00181	83 f8 05	 cmp	 eax, 5
  00184	7c fa		 jl	 SHORT $LL28@main

; 250  :     for (i = 0; i < 5; i++)

  00186	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _j5
  0018c	33 c0		 xor	 eax, eax
  0018e	66 90		 npad	 2
$LL33@main:

; 251  :         k5 = x + j5 * i;

  00190	8b d0		 mov	 edx, eax
  00192	40		 inc	 eax
  00193	0f af d1	 imul	 edx, ecx
  00196	83 c2 07	 add	 edx, 7
  00199	89 15 00 00 00
	00		 mov	 DWORD PTR _k5, edx
  0019f	83 f8 05	 cmp	 eax, 5
  001a2	7c ec		 jl	 SHORT $LL33@main

; 252  :     for (i = 0; i < 5; i++)

  001a4	33 f6		 xor	 esi, esi
$LL36@main:

; 253  :         i5 = x * k5 * i;

  001a6	8b ce		 mov	 ecx, esi
  001a8	46		 inc	 esi
  001a9	0f af ca	 imul	 ecx, edx
  001ac	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  001b3	2b c1		 sub	 eax, ecx
  001b5	a3 00 00 00 00	 mov	 DWORD PTR _i5, eax
  001ba	83 fe 05	 cmp	 esi, 5
  001bd	7c e7		 jl	 SHORT $LL36@main

; 268  :     for (i = 0; i < 6; i++)

  001bf	5f		 pop	 edi
  001c0	33 c0		 xor	 eax, eax
  001c2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _i, 0
  001cc	5e		 pop	 esi
  001cd	5b		 pop	 ebx

; 269  :         ivector4[i] = 0;

  001ce	83 f8 06	 cmp	 eax, 6
$LN84@main:
  001d1	73 1b		 jae	 SHORT $LN43@main
  001d3	33 c9		 xor	 ecx, ecx
  001d5	66 89 0c 45 00
	00 00 00	 mov	 WORD PTR _ivector4[eax*2], cx
  001dd	40		 inc	 eax
  001de	a3 00 00 00 00	 mov	 DWORD PTR _i, eax
  001e3	83 f8 06	 cmp	 eax, 6
  001e6	7c e9		 jl	 SHORT $LN84@main

; 183  :     }
; 184  : 
; 185  :     /* ───────────────────────────── *
; 186  :      │  Вызов функции с аргументами  │
; 187  :      * ───────────────────────────── */
; 188  : 
; 189  :     dead_code(1, "This line should not be printed");
; 190  : 
; 191  :     /* ────────────────────────────── *
; 192  :          │  Вызов функции без аргументов  │
; 193  :          * ────────────────────────────── */
; 194  : 
; 195  :     unnecessary_loop();
; 196  : 
; 197  :     //------------------------------------------------------
; 198  :     loop_jamming(7);
; 199  :     loop_unrolling(7);
; 200  :     jump_compression(1, 2, 3, 4, 5);
; 201  : 
; 202  : }    /* Конец функции main */

  001e8	33 c0		 xor	 eax, eax
  001ea	8b e5		 mov	 esp, ebp
  001ec	5d		 pop	 ebp
  001ed	c3		 ret	 0
$LN43@main:

; 269  :         ivector4[i] = 0;

  001ee	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN83@main:
  001f3	cc		 int	 3
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\1610036\source\repos\Lab1_Program_Languages\Lab1_Program_Languages\lab1.c
;	COMDAT _dead_code
_TEXT	SEGMENT
_dead_code PROC						; COMDAT
; _a$dead$ = ecx
; _b$dead$ = edx

; 215  :     int idead_store;
; 216  : 
; 217  :     idead_store = a;
; 218  :     if (0)
; 219  :         printf("%s\n", b);
; 220  : } /* Конец dead_code */

  00000	c2 00 00	 ret	 0
_dead_code ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\1610036\source\repos\Lab1_Program_Languages\Lab1_Program_Languages\lab1.c
;	COMDAT _unnecessary_loop
_TEXT	SEGMENT
_unnecessary_loop PROC					; COMDAT

; 232  :     int x;
; 233  : 
; 234  :     x = 0;
; 235  :     for (i = 0; i < 5; i++)  /* Цикл не должен
; 236  :                                    генерироваться*/
; 237  :         k5 = x + j5;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _j5
  00005	a3 00 00 00 00	 mov	 DWORD PTR _k5, eax
  0000a	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR _i, 5

; 238  : } /* Конец unnecessary_loop */

  00014	c3		 ret	 0
_unnecessary_loop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\1610036\source\repos\Lab1_Program_Languages\Lab1_Program_Languages\lab1.c
;	COMDAT _loop_jamming
_TEXT	SEGMENT
_loop_jamming PROC					; COMDAT
; _x$dead$ = ecx

; 250  :     for (i = 0; i < 5; i++)

  00000	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _j5
  00006	b8 07 00 00 00	 mov	 eax, 7
  0000b	56		 push	 esi
  0000c	8d 48 fe	 lea	 ecx, DWORD PTR [eax-2]
  0000f	90		 npad	 1
$LL4@loop_jammi:

; 251  :         k5 = x + j5 * i;

  00010	8b f0		 mov	 esi, eax
  00012	a3 00 00 00 00	 mov	 DWORD PTR _k5, eax
  00017	03 c2		 add	 eax, edx
  00019	83 e9 01	 sub	 ecx, 1
  0001c	75 f2		 jne	 SHORT $LL4@loop_jammi

; 252  :     for (i = 0; i < 5; i++)

  0001e	8d 14 f5 00 00
	00 00		 lea	 edx, DWORD PTR [esi*8]
  00025	33 c0		 xor	 eax, eax
  00027	b9 05 00 00 00	 mov	 ecx, 5
  0002c	2b d6		 sub	 edx, esi
  0002e	89 0d 00 00 00
	00		 mov	 DWORD PTR _i, ecx
  00034	5e		 pop	 esi
$LL7@loop_jammi:

; 253  :         i5 = x * k5 * i;

  00035	a3 00 00 00 00	 mov	 DWORD PTR _i5, eax
  0003a	03 c2		 add	 eax, edx
  0003c	83 e9 01	 sub	 ecx, 1
  0003f	75 f4		 jne	 SHORT $LL7@loop_jammi

; 254  : } /* Конец loop_jamming */

  00041	c3		 ret	 0
_loop_jamming ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\1610036\source\repos\Lab1_Program_Languages\Lab1_Program_Languages\lab1.c
;	COMDAT _loop_unrolling
_TEXT	SEGMENT
_loop_unrolling PROC					; COMDAT
; _x$dead$ = ecx

; 268  :     for (i = 0; i < 6; i++)

  00000	33 c0		 xor	 eax, eax
  00002	33 c9		 xor	 ecx, ecx
  00004	a3 00 00 00 00	 mov	 DWORD PTR _i, eax
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@loop_unrol:

; 269  :         ivector4[i] = 0;

  00010	83 f9 06	 cmp	 ecx, 6
  00013	73 1a		 jae	 SHORT $LN6@loop_unrol
  00015	33 d2		 xor	 edx, edx
  00017	66 89 14 45 00
	00 00 00	 mov	 WORD PTR _ivector4[eax*2], dx
  0001f	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00022	a3 00 00 00 00	 mov	 DWORD PTR _i, eax
  00027	8b c8		 mov	 ecx, eax
  00029	83 f8 06	 cmp	 eax, 6
  0002c	7c e2		 jl	 SHORT $LL4@loop_unrol

; 270  : } /* Конец loop_unrolling */

  0002e	c3		 ret	 0
$LN6@loop_unrol:

; 269  :         ivector4[i] = 0;

  0002f	e9 00 00 00 00	 jmp	 ___report_rangecheckfailure
_loop_unrolling ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\1610036\source\repos\Lab1_Program_Languages\Lab1_Program_Languages\lab1.c
;	COMDAT _jump_compression
_TEXT	SEGMENT
_k$dead$ = 8						; size = 4
_l$dead$ = 12						; size = 4
_m$dead$ = 16						; size = 4
_jump_compression PROC					; COMDAT
; _i$dead$ = ecx
; _j$dead$ = edx

; 281  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	b8 02 00 00 00	 mov	 eax, 2
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$beg_1$19:

; 284  :         if (j < k)

  00010	83 f8 03	 cmp	 eax, 3
  00013	7c 05		 jl	 SHORT $LN17@jump_compr

; 285  :             if (k < l)
; 286  :                 if (l < m)
; 287  :                     l += m;
; 288  :                 else
; 289  :                     goto end_1;
; 290  :             else
; 291  :                 k += l;
; 292  :         else {
; 293  :             j += k;

  00015	83 c0 03	 add	 eax, 3
$end_1$20:

; 282  : beg_1:
; 283  :     if (i < j)

  00018	eb f6		 jmp	 SHORT $beg_1$19
$LN17@jump_compr:

; 294  :         end_1:
; 295  :             goto beg_1;
; 296  :         }
; 297  :     else
; 298  :         i += j;
; 299  :     return(i + j + k + l + m);

  0001a	83 c0 12	 add	 eax, 18			; 00000012H

; 300  : } /* Конец jump_compression */

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
_jump_compression ENDP
_TEXT	ENDS
END
