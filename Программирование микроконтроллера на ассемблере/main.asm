.org $000
	JMP RESET ; Указатель на начало программы
.org INT0addr 
	JMP EXT_INT0 ; Указатель на обработчик прерывания int0 
.org INT1addr 
	JMP EXT_INT1 ; Указатель на обработчик прерывания int1

RESET:
EEPROM_read:
	sbic	EECR,EEWE
	rjmp	EEPROM_read
	out		EEARH, r18
	out		EEARL, r17
	sbi		EECR,EERE
	in		r16,EEDR

	;проверяем на корректность считанное значение
	cpi		R19, 0x01
	brlo	incorrect;если меньше 1 - там некорректное значение
	cpi		R19, 0x04
	brsh	incorrect;если больше или равно 4 - там некорректное значение
	rjmp	correct
incorrect:
	LDI		R19, 0x03;если в памяти находится некорректное значение (программа запущена впервые), то ставим 1 состояние
correct:
	;LDI		R19, 0x02;
	LDI		R20, HIGH(RAMEND) ; Старшие разряды адреса 
	OUT		SPH, R20 ; Установка вершины стека в конец ОЗУ 
	LDI		R20, LOW(RAMEND) ; Младшие разряды адреса 
	OUT		SPL, R20 ; Установка вершины стека в конец ОЗУ

	SER		R20;Регистр R20 заполняется	единицами
	OUT		DDRA, R20;Сделать порты A, B, C, D - портами вывода
	OUT		DDRB, R20	
	OUT		DDRC, R20
	LDI		R20, 0xf3
	OUT		DDRD, R20
	LDI		R16, 0x0F 
	OUT		MCUCR, R16;Настройка прерываний int0 и int1 на условие 0/1
	LDI		R16, 0xC0
	OUT		GICR, R16;Разрешение прерываний int0 и int1
	OUT		GIFR, R16 ; Предотвращение срабатывания int0 и int1 при включении прерываний
	SEI;Включить прерывания
begin:
;исходное положение: первый режим и первое состояние
	;LDI		R19, 0x03;состояние x: 1 - 0.25, 2 - 0.5, 3 - 1.0 Гц
	LDI		R18, 0x01;режим: 1 - все горят/не горят с частотой x
						    ;2 - горят 10101010/01010101 с частотой x
							;3 - на одном порту горят все лампочки, на остальных ни одной. Может быть 3 состояния
	LDI		R25, 0x03;состояние для третьего режима работы: показывает, какой светодиод горит
	LDI		R29, 0x00;регист для очистки состояния в PORTD
	ldi		R24, 0x00;номер предыдущего режима работы
	ldi		R22, 0x01;номер состояния в конкретном режиме (горят/горят и какие именно горят)

choose_mode:
	out		PORTD, R29;тушим все светодиоды - они будут установлены заново
	CPI		R18, 0x01
	BRNE	next_mode1
	cpi		R24, 0x01
	BREQ	do_1
;подготовка к началу использования режима
	ldi		R22, 0x01;подготовка=начало работы, поэтому первое состояние режима
	LDI		R24, 0x01;показываем, что режим используется
	CLR		R23;подать во все порты 0х00
	OUT		PORTA, R23
	OUT		PORTB, R23
	OUT		PORTC, R23
do_1:;если режим уже используется и подготовку проводить не надо
	sbi		PORTD, 4;устанавливаем 4 разряд - режим работы 1
	cpi		R22, 0x01
	brne	check_1
	cbi		PORTD, 7;устанавливаем бит, указывающий состояние 2 в 0
	sbi		PORTD, 6;устанавливаем бит, указывающий состояние 1 в 1
	ldi		R22, 0x02;//для следующего захода ставим 2, чтобы PORTD поменял состояние
	call	mode1
	rjmp	choose_mode
check_1:
	cbi		PORTD, 6;устанавливаем бит, указывающий состояние 1 в 0
	sbi		PORTD, 7;устанавливаем бит, указывающий состояние 2 в 1
	ldi		R22, 0x01;//для следующего захода ставим 1, чтобы PORTD поменял состояние
	call	mode1
	rjmp	choose_mode

next_mode1:
	CPI		R18, 0x02
	BRNE	next_mode2
	cpi		R24, 0x02
	BREQ	do_2
;подготовка к началу использования режима
	ldi		R22, 0x01;подготовка=начало работы, поэтому первое состояние режима
	LDI		R24, 0x02;показываем, что режим используется
	LDI		R23, 0x55;подать во все порты 0х55
	OUT		PORTA, R23
	OUT		PORTB, R23
	OUT		PORTC, R23
do_2:;режим уже используется
	sbi		PORTD, 5;устанавливаем 5 разряд - режим работы 2
	cpi		R22, 0x01
	brne	check_2
	cbi		PORTD, 7;устанавливаем бит, указывающий состояние 2 в 0
	sbi		PORTD, 6;устанавливаем бит, указывающий состояние 1 в 1
	ldi		R22, 0x02;//для следующего захода ставим 2, чтобы PORTD поменял состояние
	call	mode2
	rjmp	choose_mode
check_2:
	cbi		PORTD, 6;устанавливаем бит, указывающий состояние 1 в 0
	sbi		PORTD, 7;устанавливаем бит, указывающий состояние 2 в 1
	ldi		R22, 0x01;//для следующего захода ставим 1, чтобы PORTD поменял состояние
	call	mode2
	rjmp	choose_mode

next_mode2:
	cpi		R24, 0x03
	BREQ	do_3
;подготовка к началу использования режима
	ldi		R25, 0x03;//при этом числе программа потушит PORTC и зазжет PORTA
	LDI		R24, 0x03;показываем, что режим используется
	LDI		R23, 0xFF;подать на первый порт 0х55
	OUT		PORTA, R23
	LDI		R23, 0x00;подать на второй и третий порты 0х00
	OUT		PORTB, R23
	OUT		PORTC, R23
do_3:
	sbi		PORTD, 5;устанавливаем 5 и 4 разряды - режим работы 3
	sbi		PORTD, 4
	call	mode3;в результате в R23 0х00
	rjmp	choose_mode

mode1:
	;меняем состояние (горят/не горят)
	COM		R23
	;ldi		R23, 0xff			
	OUT		PORTA, R23
	OUT		PORTB, R23
	OUT		PORTC, R23
	call	choose_time
	ret
mode2:
	;меняем состояние (горят/не горят)
	COM		R23			
	OUT		PORTA, R23
	OUT		PORTB, R23
	OUT		PORTC, R23
	call	choose_time
	ret

mode3:
	clr		R23
	cpi		R25, 0x01
	brne	two
	;нужно потушить первую восьмерку и зажечь вторую
	out		PORTA, R23;тушим светодиоды
	com		R23;ставим 0хff
	out		PORTB, R23;зажигаем вторую восьмерку
	inc		R25;указываем, что теперь горит второй светодиод
;показываем, что теперь второй режим работы
	sbi		PORTD, 7;устанавливаем бит, указывающий состояние 2 в 1
	cbi		PORTD, 6;устанавливаем бит, указывающий состояние 1 в 0
	call	choose_time
	ret
two:
	cpi		R25, 0x02
	brne	three
;нужно потушить вторую восьмерку и зажечь третью
	out		PORTB, R23;тушим светодиоды
	com		R23;ставим 0хff
	out		PORTC, R23;зажигаем третью восьмерку
	inc		R25;указываем, что теперь горит третий светодиод
;показываем, что теперь третий режим работы
	sbi		PORTD, 7;устанавливаем бит, указывающий состояние 2 в 1
	sbi		PORTD, 6;устанавливаем бит, указывающий состояние 1 в 0
	call	choose_time
	ret
three:
;нужно потушить третью восьмерку и зажечь первую
	out		PORTC, R23;тушим светодиоды
	com		R23;ставим 0хff
	out		PORTA, R23;зажигаем третью восьмерку
	ldi		R25, 0x01;указываем, что теперь горит первый светодиод
;показываем, что теперь первый светодиод
	cbi		PORTD, 7;устанавливаем бит, указывающий состояние 2 в 0
	sbi		PORTD, 6;устанавливаем бит, указывающий состояние 1 в 1
	call	choose_time
	ret

choose_time:
;узнаем значение x, чтобы лампочки горели нужного время
	CPI		R19, 0x03	
	BRNE	next_1
	CALL	wait_1;ждем 1 сек
	ret
next_1:
	CPI		R19, 0x02
	BRNE	next_2
	CALL	wait_0_5;ждем 2 сек
	ret
next_2:
	CALL	wait_0_25;ждем 4 сек
	ret

wait_1:;z=41 y=205 x=127
	sbi		PORTD, 1;устанавливаем бит, указывающий состояние 2 в 1
	sbi		PORTD, 0;устанавливаем бит, указывающий состояние 1 в 1
	LDI		R28, 0x29
	LDI		R27, 0xcd
	LDI		R26, 0x7f
	NOP;для того, чтобы ожидание было ровно секунду
	CALL	waiting
	RET

wait_0_5:;z=82 y=140 x=0
	sbi		PORTD, 1;устанавливаем бит, указывающий состояние 2 в 1
	cbi		PORTD, 0;устанавливаем бит, указывающий состояние 1 в 0
	LDI		R28, 0x52
	LDI		R27, 0x8c
	LDI		R26, 0x00
	CALL	waiting
	RET

wait_0_25:;z = 164 y = 9 x = 2
	;показываем, что теперь первый режим работы
	cbi		PORTD, 1;устанавливаем бит, указывающий состояние 2 в 0
	sbi		PORTD, 0;устанавливаем бит, указывающий состояние 1 в 1
	LDI		R28, 0xa4
	LDI		R27, 0x09
	LDI		R26, 0x02
	CALL	waiting
	RET

waiting:
	DEC		R26
	BRNE	waiting
	DEC		R27
	CPI		R27, 0x0f
	BRNE	waiting
	DEC		R28
	BRNE	waiting
	RET

EXT_INT1:
	in		R15, SREG
	inc		R19;уменьшить время смены состояний
	cpi		R19, 0x04;проверяем, что номер режима не вышел за пределы
	BREQ	change_x;если вышел, то устанавливаем состояние 1
;Z уже подготовлен. он сначала принимает значение и оно константное
	;clr		R1;Очистить старший байт регистровой пары
	;mov		R0, R19;Установить младший байт Z - значение состояния
	;spm;записываем в eeprom по адресу для x значение Z
	call	EEPROM_write
	out		SREG, R15
	reti
change_x:
	ldi		R19, 0x01
;Z уже подготовлен. он сначала принимает значение и оно константное
	call	EEPROM_write
	out		SREG, R15
	reti

EXT_INT0:
	in		R15, SREG
	inc		R18;изменяем режим работы
	cpi		R18, 0x04;проверяем, что режим работы не вышел за границы
	BREQ	change_y//если вышел, то устанавливаем режим 1
	out		SREG, R15
	reti
change_y:
	ldi		R18, 0x01
	out		SREG, R15
	reti

EEPROM_write:
	;Дождитесь завершения предыдущей записи
	;EEWE - бит, установка которого даёт команду контроллеру записать данные из регистра данных в определенный адрес EEPROM
	;EECR - регистр управления EEPROM
	sbic	EECR,EEWE
	rjmp	EEPROM_write
	;Настройка адреса (r18:r17) в регистре адресов
	;EEARH отвечает за старший байт адреса ячейки памяти, EEARL за младший байт
	out		EEARH, r18
	out		EEARL, r17
	;Запись данных (r16) в регистр данных
	out		EEDR,r19
	sbi		EECR,EEMWE
	sbi		EECR,EEWE
ret
